defmodule Caddishouse.Documents do
  @moduledoc false
  import Ecto.Query, warn: false
  require Logger
  alias Caddishouse.Repo
  alias Caddishouse.Storage
  alias Caddishouse.Documents.{Media, Jobs}
  alias Caddishouse.Accounts.{User, OAuthUser}

  def find_or_create(attrs) do
    Ecto.Multi.new()
    |> Ecto.Multi.insert(:media, Media.build(attrs))
    |> Ecto.Multi.update(:media_with_file, &Media.add_file(&1.media, attrs))
    |> Repo.transaction()
    |> case do
      {:ok, %{media: media}} ->
        {:ok, media}

      {:error, :media_with_file, changeset, _} ->
        Logger.error("""
          Could not find or create file due to issue with file
          #{inspect(changeset)}
        """)

        {:error, changeset}

      {:error, :media, changeset, _} ->
        case Repo.get_by(Media,
               source_key: attrs["source_key"],
               oauth_user_id: attrs["oauth_user_id"]
             ) do
          nil ->
            Logger.error("""
              Could not find or create file
              #{inspect(changeset)}
            """)

            {:error, :not_found, changeset}

          media ->
            {:ok, media}
        end
    end
  end

  @doc """
  Checks whether metadata has been loaded from PDF. This does not occur during
  the import of the file or the creation of the media row in the database.

  At the moment, this occurs when the user first views the document as the
  metadata data is generated by PDF.js. So while the metadata attribute
  may exist on the media ovject, it is just empty defaults and hence, is not
  considered loaded.

  There is also a case where we update the metadata schema, in which case
  the metadata version will be increased by one and the metadata will not be 
  considered loaded anymore.
  """
  def metadata_loaded?(media) do
    !is_nil(media) and media.metadata.version == Media.Metadata.metadata_version()
  end

  def has_outline?(media) do
    metadata_loaded?(media) and !Enum.empty?(media.metadata.parts)
  end

  @doc """
  Loads metadata taken from PDF.js when the user loads the document in the browser.
  """
  def load_metadata(%Media{} = media, attrs) do
    Media.build_metadata(media, attrs)
    |> Repo.update()
  end

  defp get_by_source(%OAuthUser{} = oauth_user, source_key) when is_binary(source_key),
    do:
      Repo.get_by(Media,
        source_key: source_key,
        oauth_user_id: oauth_user.id
      )

  def import_media(%User{} = user, %OAuthUser{} = oauth_user, source_key, file_name)
      when is_binary(source_key) do
    media = get_by_source(oauth_user, source_key)

    if is_nil(media) do
      %{
        user_id: user.id,
        oauth_user_id: oauth_user.id,
        source_key: source_key,
        file_name: file_name
      }
      |> Jobs.ImportMedia.new()
      |> Oban.insert()

      {:ok, :processing_media}
    else
      {:ok, media}
    end
  end

  def get_by_id!(%User{} = user, id, preload \\ []) do
    Repo.one!(from m in Media, where: m.id == ^id and m.user_id == ^user.id, preload: ^preload)
    |> Media.last_viewed()
    |> Repo.update!()
  end

  def search(%User{} = user, query) do
    query = "%#{query}%"
    Repo.all(from m in Media, where: ilike(m.name, ^query) and m.user_id == ^user.id)
  end

  def recently_viewed(%User{} = user, limit \\ 10) do
    Repo.all(
      from m in Media,
        where: m.user_id == ^user.id and not is_nil(m.last_viewed_at),
        order_by: [desc: :last_viewed_at],
        limit: ^limit
    )
  end

  def update_current_page(%Media{} = media, current_page) do
    Media.current_page(media, current_page)
    |> Repo.update()
    |> case do
      {:error, _changeset} = error ->
        Logger.error("""
          Could not update current page '#{current_page}' of Media: #{media.id}
          #{inspect(error)}
        """)

        error

      ok ->
        ok
    end
  end

  def delete_media(%User{} = _user, %Media{} = media) do
    with {:ok, _} <- Storage.delete(media),
         {:ok, media} <- Repo.delete(media) do
      media
    else
      {:error, error} ->
        Logger.error("""
          Could not delete media id: #{media.id}
          #{inspect(error)}
        """)
    end
  end

  def get_media_url(%Media{} = media) do
    Storage.get_url(media)
  end
end
